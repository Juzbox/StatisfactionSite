<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GIF Network Visualization</title>
    <style>
        :root {
            /* Color variables for easy adjustment */
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --text-tertiary: #999999;
            --text-hover: #ffffff;
            --label-bg: rgba(255,255,255,0.9);
            --label-text: rgba(0, 0, 0, 0.85);
            --description-bg: rgba(0, 0, 0, 0);
            --description-text: var(--text-primary);
            --keyword-bg: rgba(255,255,255,0.9);
            --keyword-text: rgba(0, 0, 0, 0.85);
            --connection-color: white;
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: Lucida Console, monospace;
            background: linear-gradient(45deg, #000000, #1F2729, #270B2E);
            background-size: 400% 400%;
            animation: backgroundShift 15s ease infinite;
        }
        
        @keyframes backgroundShift {
            0% { background-position: 0% 50%; }
            33% { background-position: 50% 50%; }
            66% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        #network-container {
            width: 100%;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }
        
        /* Node GIF styling */
        .node-gif {
            position: absolute;
            pointer-events: all;
            cursor: move;
            transition: filter 0.2s;
            user-select: none;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }
        
/*        .node-gif:hover {
            filter: drop-shadow(0 8px 16px rgba(0,0,0,0.5));
            z-index: 100 !important;
        }*/
        
        /*.node-gif img {
            display: block;
            max-width: 400px;
            height: auto;
            pointer-events: none;
            mix-blend-mode: multiply;
        }*/
        
/*        .node-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--label-bg);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: bold;
            color: var(--label-text);
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }*/
        
       /* .node-gif:hover .node-label {
            opacity: 1;
        }*/
        
        .node-description {
            position: absolute;
            
            bottom: 40px;
            right: 10px;
            background: var(--description-bg);
            padding: 5px 5px;
            border-radius: 1px;
            font-size: 18px;
            line-height: 1.2;
            color: var(--description-text);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: auto;
            text-shadow: 0 4px 12px rgba(0,0,0,50);
/*            box-shadow: 0 4px 12px rgba(0,0,0,0.5);*/
            z-index: 200;
          width: min-content;  /* ‚Üê Add this line */
    
        }
        
       /* .node-description-title {
            font-weight: bold;
            margin-bottom: 6px;
            font-size: 14px;
            color: var(--text-hover);
        }*/
        
        .node-gif:hover .node-description {
            opacity: 1;
        }
        
        /* Keep description visible when hovering over it */
        .node-description:hover {
            opacity: 1;
        }
        
        /* Connection lines */
        svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        .connection-line {
            stroke: var(--connection-color);
            stroke-width: 1;
            opacity: 0.4;
            stroke-dasharray: 1, 2;
        }
        
        .connection-label {
            position: absolute;
            background: var(--keyword-bg);
            color: var(--keyword-text);
            padding: 3px 8px;
            border-radius: 8px;
            font-size: 10px;
            white-space: nowrap;
            pointer-events: none;
            z-index: 5;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="network-container">
        <svg id="connections"></svg>
    </div>

    <script>
        // GIF data with keywords
        const gifData = [
            { 
                id: 1, 
                filename: '001_industrialisis.gif', 
                title: '001_industrialisis', 
                keywords: ['animation', 'machinery', 'escape', 'rythm'],
                description: 'Created using old animation.'
            },
            { 
                id: 2, 
                filename: '002_bursting.gif', 
                title: '002_bursting', 
                keywords: ['animation', 'enchanted', 'breaking'],
                description: 'Created layering two classics of my childhood.'
            },
            { 
                id: 3, 
                filename: '003_innercalling.gif', 
                title: '003_inner calling', 
                keywords: ['animation', 'pigeon', 'escape', 'defense'],
                description: 'Layered scans of physical spaces compressed into digital fragments. Reality reconstructed through technological aggregation.'
            },
            { 
                id: 4, 
                filename: '004_nosy.gif', 
                title: '004_nosy', 
                keywords: ['animation', 'linework', 'monarch'],
                description: 'the king and the mockingbird.'
            },
            { 
                id: 5, 
                filename: '005_organitious.gif', 
                title: '005_organitious', 
                keywords: ['organs', 'farming', 'rythm'],
                description: 'Exploring new worlds.'
            },
            { 
                id: 6, 
                filename: '006_gazaplatsen.gif', 
                title: '006_gazaplatsen', 
                keywords: ['3D scan', 'Palestine', 'Gothenburg', 'breaking'],
                description: 'Fighting against erasure.'
            },
        ];

        const container = document.getElementById('network-container');
        const svg = document.getElementById('connections');
        const containerRect = container.getBoundingClientRect();
        
        // Node positions and physics
        const nodes = [];
        const nodeElements = {};
        let physicsEnabled = true;
        let animationEnabled = false;
        let draggedNode = null;

        // Initialize nodes with circular layout
        gifData.forEach((gif, index) => {
            const angle = (index / gifData.length) * Math.PI * 2;
            const radius = 200;
            const centerX = containerRect.width / 2;
            const centerY = containerRect.height / 2;
            
            // Random max-width between 400 and 600
            const randomMaxWidth = 400 + Math.random() * 200;
            
            nodes.push({
                id: gif.id,
                data: gif,
                x: centerX + Math.cos(angle) * radius,
                y: centerY + Math.sin(angle) * radius,
                baseX: centerX + Math.cos(angle) * radius,
                baseY: centerY + Math.sin(angle) * radius,
                vx: 0,
                vy: 0,
                noiseOffsetX: Math.random() * 1000,
                noiseOffsetY: Math.random() * 1000,
                maxWidth: randomMaxWidth
            });
        });

        // Create connections based on shared keywords
        const connections = [];
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                const sharedKeywords = nodes[i].data.keywords.filter(
                    keyword => nodes[j].data.keywords.includes(keyword)
                );
                if (sharedKeywords.length > 0) {
                    connections.push({
                        from: nodes[i],
                        to: nodes[j],
                        strength: sharedKeywords.length,
                        keywords: sharedKeywords
                    });
                }
            }
        }

        // Create DOM elements for nodes
        nodes.forEach(node => {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'node-gif';
            nodeDiv.style.left = node.x + 'px';
            nodeDiv.style.top = node.y + 'px';
            nodeDiv.style.transform = 'translate(-50%, -50%)';
            nodeDiv.style.zIndex = '10';
            
            const img = document.createElement('img');
            img.src = `gifs/${node.data.filename}`;
            // img.alt = node.data.title;
            img.draggable = false;
            img.style.maxWidth = node.maxWidth + 'px';
            
            // Store reference to set description width after image loads
            img.onload = function() {
                const actualWidth = this.offsetWidth;
                const descElement = nodeDiv.querySelector('.node-description');
                if (descElement) {
                    descElement.style.width = actualWidth + 'px';
                }
            };
            
            const label = document.createElement('div');
            // label.className = 'node-label';
            label.textContent = node.data.title;
            
            const description = document.createElement('div');
            description.className = 'node-description';
            
            const descTitle = document.createElement('div');
            descTitle.className = 'node-description-title';
            descTitle.textContent = node.data.title;
            
            const descText = document.createElement('div');
            descText.textContent = node.data.description || '';
            
            description.appendChild(descTitle);
            description.appendChild(descText);
            
            nodeDiv.appendChild(img);
            // nodeDiv.appendChild(label);
            nodeDiv.appendChild(description);
            container.appendChild(nodeDiv);
            
            nodeElements[node.id] = nodeDiv;
            
            // Drag functionality
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            nodeDiv.addEventListener('mousedown', (e) => {
                isDragging = true;
                draggedNode = node;
                startX = e.clientX;
                startY = e.clientY;
                initialX = node.x;
                initialY = node.y;
                nodeDiv.style.cursor = 'grabbing';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging && draggedNode === node) {
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    node.x = initialX + dx;
                    node.y = initialY + dy;
                    node.baseX = node.x;
                    node.baseY = node.y;
                    node.vx = 0;
                    node.vy = 0;
                    updateNodePosition(node);
                    drawConnections();
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isDragging && draggedNode === node) {
                    isDragging = false;
                    draggedNode = null;
                    nodeDiv.style.cursor = 'move';
                }
            });
        });

        // Physics simulation
        function applyPhysics() {
            if (!physicsEnabled) return;
            
            const centerX = containerRect.width / 2;
            const centerY = containerRect.height / 2;
            
            // Apply forces
            nodes.forEach(node => {
                if (draggedNode === node) return;
                
                // Repulsion between nodes
                nodes.forEach(other => {
                    if (node === other) return;
                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = 5000 / (dist * dist);
                    node.vx += (dx / dist) * force;
                    node.vy += (dy / dist) * force;
                });
                
                // Spring forces for connections
                connections.forEach(conn => {
                    if (conn.from !== node && conn.to !== node) return;
                    const other = conn.from === node ? conn.to : conn.from;
                    const dx = other.x - node.x;
                    const dy = other.y - node.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const targetDist = 250;
                    const force = (dist - targetDist) * 0.001 * conn.strength;
                    node.vx += (dx / dist) * force;
                    node.vy += (dy / dist) * force;
                });
                
                // Center gravity
                const dx = centerX - node.x;
                const dy = centerY - node.y;
                node.vx += dx * 0.0001;
                node.vy += dy * 0.0001;
                
                // Damping
                node.vx *= 0.85;
                node.vy *= 0.85;
                
                // Update position
                node.x += node.vx;
                node.y += node.vy;
                
                // Update base position for floating
                node.baseX = node.x;
                node.baseY = node.y;
                
                // Boundary
                const margin = 150;
                node.x = Math.max(margin, Math.min(containerRect.width - margin, node.x));
                node.y = Math.max(margin, Math.min(containerRect.height - margin, node.y));
            });
        }

        // Noise function for floating effect
        function noise(x) {
            const X = Math.floor(x) & 255;
            x -= Math.floor(x);
            const u = fade(x);
            return lerp(u, grad(X, x), grad(X + 1, x - 1)) * 2 - 1;
        }
        
        function fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        }
        
        function lerp(t, a, b) {
            return a + t * (b - a);
        }
        
        function grad(hash, x) {
            return (hash & 1) === 0 ? x : -x;
        }

        // Apply floating effect
        function applyFloating() {
            if (!animationEnabled || physicsEnabled) return;
            
            const time = Date.now() * 0.0003;
            
            nodes.forEach(node => {
                if (draggedNode === node) return;
                const noiseX = noise(time + node.noiseOffsetX) * 3;
                const noiseY = noise(time + node.noiseOffsetY) * 3;
                node.x = node.baseX + noiseX;
                node.y = node.baseY + noiseY;
            });
        }

        // Update node visual position
        function updateNodePosition(node) {
            const element = nodeElements[node.id];
            element.style.left = node.x + 'px';
            element.style.top = node.y + 'px';
        }

        // Draw connection lines
        function drawConnections() {
            svg.innerHTML = '';
            
            // Remove existing connection labels
            document.querySelectorAll('.connection-label').forEach(label => label.remove());
            
            connections.forEach(conn => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', conn.from.x);
                line.setAttribute('y1', conn.from.y);
                line.setAttribute('x2', conn.to.x);
                line.setAttribute('y2', conn.to.y);
                line.setAttribute('class', 'connection-line');
                line.setAttribute('stroke-width', conn.strength * 2);
                svg.appendChild(line);
                
                // Add keyword label at center of line
                const centerX = (conn.from.x + conn.to.x) / 2;
                const centerY = (conn.from.y + conn.to.y) / 2;
                
                const label = document.createElement('div');
                label.className = 'connection-label';
                label.textContent = conn.keywords.join(', ');
                label.style.left = centerX + 'px';
                label.style.top = centerY + 'px';
                label.style.transform = 'translate(-50%, -50%)';
                container.appendChild(label);
            });
        }

        // Animation loop
        function animate() {
            if (physicsEnabled) {
                applyPhysics();
            } else {
                applyFloating();
            }
            
            nodes.forEach(updateNodePosition);
            drawConnections();
            
            requestAnimationFrame(animate);
        }

        // Stabilize physics first
        let stabilizationCounter = 0;
        const stabilizationInterval = setInterval(() => {
            applyPhysics();
            nodes.forEach(node => {
                node.baseX = node.x;
                node.baseY = node.y;
                updateNodePosition(node);
            });
            drawConnections();
            stabilizationCounter++;
            if (stabilizationCounter > 100) {
                clearInterval(stabilizationInterval);
                physicsEnabled = false;
                setTimeout(() => {
                    animationEnabled = true;
                    animate();
                }, 500);
            }
        }, 20);
    </script>
</body>
</html>
